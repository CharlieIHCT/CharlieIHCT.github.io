[{"title":"深度學習到底如何運作？","path":"2023/12/14/DeepLearning/","text":"深度學習認識神經網路神經元(Neuron)構造 細胞本體：控管整個神經元。 樹突：輸入。 神經纖維：傳遞訊息，如果越常使用，此神經會的反應會越明顯。 軸突：輸出。 運作方式 感知器(Perceptron) 構造 x：輸入數值。 w：權重，代表輸入數值的重要程度，正如神經纖維的反應會變動一樣，這表示權重的數值會不斷的改變，這也是為甚麼AI模型需要經過不斷的訓練。 φ：激勵函數，規範數值的範圍 b：偏移，加權總和要超過甚麼數字才有意義，用以規範數值有意義的範圍。 h：輸出數值，也就是所獲得的結果。 以圖像來思考，綠色為正的權重，紅色為負的權重，顏色愈亮代表與0的差距越大。神經元透過權重來計算下一層神經元所注重的圖像。而我們可以將我們所要的圖像外的權重值都改為0。如果想要確認圖形的邊，可以在外圍的偏移改為負的權重，就可以得到最大的加權總和。 什麼是邏輯函數(Sigmoid Function)，這個函數有什麼特別之處?我們想要計算權重的總和，加權總和可能為任意實數，但我們需要將加權總和壓縮在01之間(不包含0且不包含1)以便利用，sigmoid function(邏輯函數)就是使加權總和壓縮在01之間的工具，如圖。 眼尖的人應該有發現，方程式內的稱為激勵函數，而下文介紹的是邏輯函數，事實上，邏輯函數只是激勵函數的一種，激勵函數還有ReLU、tanh、Maxout函數等等，範圍也不僅限於0或1之間，不過那是另一個故事了 那到底為甚麼要套入激勵函數呢，因為如果不這麼做，會導致方程式為線性函數，那為甚麼會是線性函數呢？以國中數學舉例來說，f(x) &#x3D; 2x +1，g(x) &#x3D; 3f(x) + 2，則f(x)帶入後會得到g(x) &#x3D; 3(2x+1) +1，g(x)&#x3D; 6x+4，還是一個線性函數。 這代表你只要給了每個輸出都獨立對一個輸出，一開始就是因為沒有加上這個邏輯函數導致原函數是線性的，這個線性函數解決不了exclusive or的問題。 如圖，一條線是無法分開綠色的點與紅色的點的。這也導致連結主義學派沒落好一段時間…… 多層感知機運作方式 多層感知機是一種前向傳遞類神經網路，還有一點要注意的是隱藏層並不是越多越好。 也有反向傳遞的方式，在損失函數調整偏值後，會重新調整先前所有權重的值，用來降低誤差 其餘更詳細歡迎看：機器學習-神經網路-多層感知機 資料來源：But what is a neural network? | Chapter 1, Deep learning Demystifying the XOR problem"},{"title":"認識AI與機器學習","path":"2023/12/10/learning_ai/","text":"先來說說AI是甚麼，人工智慧（AI）是指讓機器展現出與人類智慧相似的能力和行為的領域，重點在於思考與理解的能力。 而機器學習是AI的一個子集，關係圖如下，它是通過讓機器從數據中學習和改進，自動提取模式、規則和知識，從而實現各種任務，例如圖像識別、語音辨識、自然語言處理等。 AI工程師有哪些？資料分析師&#x2F;數據分析師(Data Analyst) 資料分析師是負責收集、整理、分析和解釋數據的專業人員。主要使用統計和分析工具(清洗與分析)，用圖表以展現數據中的模式、趨勢和關聯性(視覺化處理)，進而提供對市場或公司的資料觀察結果。 需要了解的知識有： Matplotlib(常用) 統計學 Seaborn 友情推薦：粉專-資料科學家的工作日常 資料工程師(Data Engineer) 資料工程師是負責設計、構建、維護和處理大規模數據的專業人員，需要把凌亂的資料轉成乾淨的資料，他們主要關注的是數據的流動、轉換和儲存(資料庫)。 需要了解的知識有： SQL database(SEL, Structured Query Language結構化查詢語言) Python(資料處理) Machine Learning 資料科學家(Data Scientist) 與資料分析師類似，一樣需要對資料進行清洗、分析、視覺化，不過更注重在於構建機器學習模型並訓練用於分析或是預測數據。 需要了解的知識有： PyTorch or TensorFlow 統計學 製作model(模型) 延伸閱讀資料工程師們到底在做什麼資料分析師、資料科學家、資料工程師傻傻分不清楚？一文徹底講清區別 把問題化為函數函數函數，其實與數學上所說的函數一樣，即為function之意。 X 是定義域，Y 是值域，每一個 X 裡的元素，都要對應到 Y 裡的一個元素，而且只能對到一個。 用人話說，就是函數(function)是一個解答本，X是所有可能的題目（問題）， Y 則是所有可能的答案。 函數的定義就是讓所有的題目都要有解答，並且是唯一的答案。 AI解決問題的過程1.先問一個問題 一個問題有很多不同的問法，有時我們不能直接問這個問題，而是要換一種方式來問。 「問一個好問題」是人工智慧中最重要的部分之一了！ 2.把問題化成函數的形式 所有的問題都需要有解答，我們需要函式來讓我們得到答案。 3.收集歷史資料 接著，AI需要蒐集「考古題」，經過大量收集歷史數據後，才能讓解答本越來越完善。 但AI就像班上那些背科很強的同學，他也會把考古題背起來，但如果遇到沒有看過的題目，他就會回答得非常離譜，這種狀況叫做過適或過度擬合(overfitting)。 4.打造一個函數學習機 這是使AI有思考能力的轉捩點，透過機器學習(machine learning)或神經網路(neural network)等方法來建構函數學習機，經過大量的資料學習過後，直到找到一個最好的參數來滿足我們所想要的函式，函數學習機就完成了。 舉例來說，我們想要找到最適直線y &#x3D; wx + b，當我們決定好(w, b) &#x3D; (2, 3)時，函數學習機就完成了 5.訓練 最後要訓練函數學習機，每次的訓練都會調整我所設定的參數，使函式更接近理想函式。 以最適直線來舉例，實際的數據也不一定會在最適直線上，那我們需要知道差的值到底是多少。就會透過損失函數來計算誤差，所以好的函數會希望損失函數越來越小。 損失函數有很多種，例如我們高中學過的最小平方法 補充一下，使用平方是為了避免負值，那就可能有人問了，那為甚麼不用絕對值呢？這是因為在更高維度的時候可能就不只有一個維度的正負了，再者，平方後也可以擴大離散差距，也能讓更方便應用微積分。 資料的處理步驟與流程 img[alt=data-processing-flow] { width: 30%;} 預處理的目的？ 去除雜質(不必要的東西) 將資料轉換成方便電腦閱讀的形式 甚麼是候選模型？訓練出來會有很多個模型，假設有100個模型，在這裡我們可能會選出最好的三個模型，作為我們的候選模型。最後再選出一位最佳候選模型，作為Golden Model(金鑰模型)。 機器學習(ML)演算法分類與分群分類 Classification就是將物品分類至已經存在的類別 以函數表示會像這樣： YLabel1=f1(x1,x2,...,xn)Y_{Label1} = f_1(x_1, x_2, ..., x_n)YLabel1​=f1​(x1​,x2​,...,xn​) YLabel2=f2(x1,x2,...,xn)Y_{Label2} = f_2(x_1, x_2, ..., x_n)YLabel2​=f2​(x1​,x2​,...,xn​) 分類的結果稱為標籤(Label)，也就是Y &#x3D; function 判斷結果的資料叫做特徵(Feature)，也就是x1,x2…。 簡單來說，就是將特徵(Feature)分類到已知的種類資訊，得到標籤(Label) 分群 Clustering將物品分成至尚未存在的類別 其他跟分類一樣， 分群的結果稱為標籤(Label) 判斷結果的資料叫做特徵(Feature) 簡單來說，就是將特徵(Feature)分群到未知的種類資訊，得到標籤(Label) 機器學習類別 監督式學習 非監督式學習 半監督式學習 強化式學習 資料來源 有標記(labeled) 無標記(labeled) 混合有標記與無標記 與環境互動 方法 將已知迴歸分析 從未知尋找既定模式(例如K平均演算法) 提升模型正確率 透過正面回饋與負面回饋尋找最大效益 優點 準確率高 不需要標籤 標註成本低、數量少 效率較高 缺點 需要大量人力作業 可能造成不具重要性的特徵被過度放大 可能造成不具重要性的特徵被過度放大 容易過度擬合"},{"title":"[APCS] 2016/03 矩陣轉換","path":"2023/11/11/apcs_2016_03/","text":"第 2 題 矩陣轉換題目連結 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960#輸入R, C, M = map(int, input().split())matrix = []for i in range(R): x = list(map(int, input().split())) matrix.append(x)moves = list(map(int, input().split()))&quot;&quot;&quot;原本的輸出經過1,0,0才得到後來的圖形則後來的圖形需要經過0,0,1才能得到原來的圖形&quot;&quot;&quot;moves = list(reversed(moves))#翻轉與旋轉def flip(matrix): &quot;&quot;&quot; 讀取行(橫的)，這裡直接用reversed函式就好，記得外面要加list() [1, 1] -&gt; [1, 2] [3, 1] -&gt; [3, 1] [1, 2] -&gt; [1, 1] &quot;&quot;&quot; return list(reversed(matrix))def rotate_left(matrix): &quot;&quot;&quot; 讀取列(直的)， index:(0,0)(1,0)(2,0)(0,1)(1,1)(2,1) [1, 2] -&gt; [1, 3, 1] -&gt; [2, 1, 1] [3, 1] -&gt; [2, 1, 1] -&gt; [1, 3, 1] [1, 1] -&gt; &quot;&quot;&quot; temp = [] row = len(matrix) col = len(matrix[0]) for i in range(col): temp_row = [] for k in range(row): temp_row.append(matrix[k][i]) temp.append(temp_row) return list(reversed(temp))#執行movesfor i in range(M): if moves[i] == 1: matrix = flip(matrix) elif moves[i] == 0: matrix = rotate_left(matrix)#輸出ROW = len(matrix)COL = len(matrix[0])print(ROW, COL)for k in range(ROW): print(*matrix[k]) 第 3 題 線段覆蓋長度題目連結 1234567891011121314151617181920212223242526272829303132#輸入N = int(input())lines = []for i in range(N): x = list(map(int, input().split())) lines.append(x)#由小排到大，等等好擴張線段大小lines.sort()start = lines[0][0] #起始線段的左邊end = lines[0][1] #起始線段的右邊sum = 0 #判斷for i in lines: left = i[0] right = i[1] if end &lt; left:#沒有覆蓋到線段 #計算獨立線段長度 sum += end - start #線段轉換成一個 start = left end = right else:#覆蓋到線段 #保持原有線段擴張 end = max(end, right)#最後剩下的那個線段記得加sum += end - start#輸出print(sum)"},{"title":"從純文字到精美文件|10分鐘帶你看完Markdown全語法","path":"2023/10/21/MarkdownSyntax/","text":"前言甚麼是MarkDown?Markdown是一種輕量級標記語言，目標很簡單，就是實現「易讀易寫」。並在不需要特殊複雜排版的情況下就能輕鬆地將內容轉換為HTML或其他格式。 為甚麼你該學Markdown?Markdown文本在原始形式下很容易閱讀，就像一般的記事本一樣，頂多就是多了一些明顯的符號(例如星號**用於標記強調文字)。 最重要的是許多平台都已經可以使用Markdown語法來撰寫留言、文件了，例如Github、Stack Overflow、甚至是Discord、Youtube、Line等等通訊、娛樂軟體都或多或少的支援Markdown。 簡單的說，Markdown已經是我們在大數位時代中的一個不可或缺的知識。 基礎寫法標題最多從h1~h6。 Code123456789# h1## h2### h3#### h4h1===h2--- Showcase分隔線Code12345* * *********- - ---------------------------------------- Showcase 換行Code123直接按enter是不管用的！ 換行是兩個空格 + enter Showcase直接按enter是不管用的！換行是 兩個空格 + enter 列表無序列表Code12345- 項目1 + 子項目1 - 子項目2+ 項目2* 項目3 Showcase 項目1 子項目1 子項目2 項目2 項目3 有序列表Code123453. 列表的數字只會照著第一個數下去 1. 第一個子項目 3. 第二個子項目2. 第二個項目1. 第三個項目 Showcase 列表的數字只會照著第一個數下去 第一個子項目 第二個子項目 第二個項目 第三個項目 勾選Code12- [ ] 去買蛋餅- [x] 刷一題code Showcase 去買蛋餅 刷一題code 引用&#x2F;註解Code12&gt; 你好，我是註解&gt;&gt; 你好，我是註解中的註解 Showcase 你好，我是註解 你好，我是註解中的註解 斜體(Italic type)與強調(Bold)Code123456*一個星號* _一個底線_ **兩個星號** __兩個底線__ ***三個星號*** ___三個底線___ Showcase 一個星號一個底線兩個星號兩個底線三個星號三個底線 超連結[顯示文字](連結) Code123[點我會到google喔(ﾉ&gt;ω&lt;)ﾉ](http://google.com) [點我會到google喔(ﾉ&gt;ω&lt;)ﾉ](http://google.com &quot;欸呦這可以到Google欸&quot;) 滑鼠放在上面會看到註解 Showcase 點我會到google喔(ﾉ&gt;ω&lt;)ﾉ點我會到google喔(ﾉ&gt;ω&lt;)ﾉ滑鼠放在上面會看到註解 那如果常常要用同一個超連結怎麼辦？我們可以使用超連結標籤。在任意地方定義 [id]:連結 “備註” 這段代碼。(我個人覺得這很像變數的概念，有點像 id &#x3D; http://google.com ，並重複使用id變數的感覺。) Code12345[123]: http://google.com &quot;這是GOOGLE網址&quot; [123][Y]: http://youtube.com [Y] Showcase 123 Y 程式碼文字中程式碼Code1用個單個`code`引號就好 Showcase 用個單個code引號就好 如果不希望引號內變成程式碼呢？或是程式碼內有單引號呢？可以用兩個單引號包起來，或是在單引號前加上\\，當然，用html寫也可以。 Code12345``一堆`單`引`號`。`` &lt;p&gt;一堆`單`引`號`。&lt;p&gt;一堆\\`單\\`引\\`號\\`。 Showcase一堆`單`引`號`。 一堆`單`引`號`。 一堆`單`引`號`。 圖片![屬性註解](圖片連結) 或是 [![屬性註解](圖片連結)](超連結) Code12![烏龜](https://cdn3.emoji.gg/emojis/8947-turtle4k.png)[![能點的烏龜](https://cdn3.emoji.gg/emojis/8947-turtle4k.png)](https://emoji.gg/emoji/8947-turtle4k) Showcase 有沒有覺得烏龜太大隻？如果想調整圖片大小，就只能用html或css來處理： Code12345&lt;img src=&quot;https://cdn3.emoji.gg/emojis/8947-turtle4k.png&quot; with=&quot;200px&quot; alt=&quot;第三隻烏龜&quot;&gt; ![第四隻烏龜](https://cdn3.emoji.gg/emojis/8947-turtle4k.png) &lt;style&gt;img[alt=第四隻烏龜] &#123; width: 40%; &#125;&lt;/style&gt; Showcase img[alt=第四隻烏龜] { width: 40%; } img[alt=第三隻烏龜] { width: 200px; } 表格Code123456789| 你 | 好 | 阿 | | ----- | ----- | ----- | | ABC | DEF | GHI | | JKL | MNO | PQR || 左對齊 | 右對齊 | 居中對齊 | | :-----| ----: | :----: | | ABC | DEF | GHI | | JKL | MNO | PQR | Showcase 你好嗎 我很好阿 真的還假的 ABC DEF GHI JKL MNO PQR 左對齊 右對齊 居中對齊 ABC DEF GHI JKL MNO PQR 進階寫法🚧🚧🚧🚧🚧仍在努力製作中&gt;&lt;"},{"title":"我架設了一個Blog。","path":"2023/10/14/Origin_of_Blog/","text":"創造這個網站的原因？你好，歡迎來到這個網站的起源，這是這個網站的第一篇文章原本想創這個網站是為了放自己刷leetcode心得，順便練習html,css,js，後來想說就把一些學到的東西都丟上來，自己當筆記看以外還可以讓更多有興趣的人了解這些資訊 從bootstrap到hexo於是乎，我就馬上找了個bootstrap範本開始研究，稍微改了一點東西就丟到github pages了，然後我就發現這樣要寫文章真的超麻煩啊!!!!!! 要手動去github新增新的html不說，當文章多起來的時候，重要標籤、搜尋功能都不存在，這樣到底怎麼找文章啦😭於是我就開始另闢蹊徑，最終決定使用hexo來架起我的Blog 架好了，在此留下我的喜悅！1print(&quot;^_^ Say hello to my little friend!&quot;) 最後想說的話距離高三還有一年，我想這段時間還是能夠在這裡挺活躍的，不過當然同時也要準備好課業喔各位，不要像我一樣整天亂亂搞！感謝聽我廢話到這邊~希望以後也能常常相見！ 更瞭解我: About Me"}]