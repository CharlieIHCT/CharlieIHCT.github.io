[{"title":"page","path":"2024/05/18/page/","text":""},{"title":"leetcode 509. fibonacci-number","path":"2024/03/24/fibonacci/","text":"費波那契數列可延伸：dynamic programming、recursion https://leetcode.com/problems/fibonacci-number/ 12F(0) = 0, F(1) = 1F(n) = F(n - 1) + F(n - 2), for n &gt; 1. 遞迴解 Recursion12345class Solution: def fib(self, n: int) -&gt; int: if n &lt;= 1: return n return self.fib(n-1) + self.fib(n-2) 因為是遞迴解，每次都要重複call自己的function好幾次，並且透過觀察就可以知道，以n&#x3D;5為舉例，fib(3)會被call兩次，所以速度當然非常慢。要遞迴兩個函數，每次都要重複兩個子funciton，所以時間複雜度為**O(2^n)，空間複雜度為O(n)**。 DP解 Dynamic Programming 動態編程的目的就是用空間換取時間，只要每次運算完先把數值記憶起來，下一ˊ次計算再把數值出來就好，這樣就可以省下call function的時間！ 12345678910class Solution: def fib(self, n: int) -&gt; int: if n &lt;= 1: return n table = [0 for _ in range(9999)] table[1] = 1 for i in range(2, n+1): table[i] = table[i-1] + table[i-2] return table[n] 因為我們預先建立了一個名為table的list，然後每次都從table提數值出來，計算完再把數值存到table裡面，所以時間複雜度為**O(n)，空間複雜度為O(n)**。 迭代解 Iteration 跟dp解差不多，只是我們並沒有先建好table，而是計算完就append到table，不過儲存的邏輯是一樣的。 123456789class Solution: def fib(self, n: int) -&gt; int: if n &lt;= 1: return n table = [0, 1] for i in range(2, n+1): table.append(table[i-1] + table[i-2]) return table[n] 變數解 Variable 講到list，第一個想到的就是mutable，但是如果我們今天只是存在變數裡呢？不需要讓table存下計算過程所有的解，而是專注在答案。優點是空間複雜度變小，缺點是無法提取計算過的數字。 12345678910111213class Solution: def fib(self, n: int) -&gt; int: if n &lt;= 1: return n now = 0 prev = 1 ans = 0 for i in range(2, n+1): ans = now + prev now = prev prev = ans return ans 因為計算邏輯都一樣，時間複雜度仍然為**O(n)，但我們只用三個變數來執行這個功能，每次都是直接從變數取出來，不需要占用儲存空間，所以空間複雜度為O(1)**。"},{"title":"MineSweeper踩地雷|python超簡單教學#1","path":"2024/02/02/MineSweeper/","text":"今天用Python Class來做一個大家都玩過的遊戲，踩地雷，在做這個專案之前我也覺得很難，主要是沒看到甚麼比較清楚的教學，但實際上只要我們先將遊戲拆成很多個不同的區段來處理就會簡單許多，這也是程式中很重要的概念，即分治法，把大問題先分成一個一個小問題來看，這樣就會簡單上許多了。 思考先來看踩地雷的遊戲過程是甚麼吧！ 遊戲版面由一個矩形方格組成，其中隨機分佈地雷。 玩家需要揭開它們，每個方塊上的數字代表周圍8個方塊中地雷的數量。 如果玩家揭開了一個地雷，遊戲就會結束。 由上述可知，我們的流程大概可以想成： 創建矩形board→需要二維陣列→用迴圈把board建好→隨機分布地雷→用random→用迴圈檢查附近有幾個地雷→得到每格的數字→印出供遊玩的board→玩家輸入要挖哪裡→完成🥰 「組」出遊戲import123import randomimport timeimport os board class init 1234567891011def __init__(self, size, num_bombs): #size and num_bombs self.width = size[0] self.height = size[1] self.size = self.width * self.height self.num_bombs = num_bombs #create_board self.board = self.create_board() self.set_block_values() #save blocks which have dug self.dug = set() board &amp; bombs 1234567891011121314151617181920212223def create_board(self): #create empty board board = [[None for c in range(self.width)] for r in range(self.height)] &quot;&quot;&quot; board = [None, None, ..., None], [None, None, ..., None], [None, None, ..., None], [None, None, ..., None] &quot;&quot;&quot; for _ in range(self.num_bombs): location = random.randint(0, self.size -1) row = location // self.height#y col = location % self.width#x board[row][col] = &#x27;💣&#x27; &quot;&quot;&quot; #this is fine also row = random.randint(0, self.height - 1) col = random.randint(0, self.width - 1) board[row][col] = &#x27;💣&#x27; &quot;&quot;&quot; return board block number 123456def set_block_values(self): for r in range(self.height): for c in range(self.width): if self.board[r][c] == &#x27;💣&#x27;:#bomb continue self.board[r][c] = self.calculate_nearby_bombs(r, c) nearby bombs 123456789101112131415def calculate_nearby_bombs(self, row, col): #make sure not to go out of bounds &quot;&quot;&quot; [None -&gt; None -&gt; None], [None -&gt; block(continue) -&gt; None], [None -&gt; None -&gt; None], &quot;&quot;&quot; num_nearby_bombs = 0 for r in range(max(0, row-1), min(self.height-1, row+1) + 1): for c in range(max(0, col-1), min(self.width-1, col+1) + 1): if (r==row and c==col): continue#don&#x27;t count the spot itself as a nearby bomb elif self.board[r][c] == &#x27;💣&#x27;: num_nearby_bombs += 1 return num_nearby_bombs dig 123456789101112131415def dig(self, row, col): self.dug.add((row, col))#add to set if self.board[row][col] == &#x27;💣&#x27;:#bomb return False elif self.board[row][col] &gt; 0:#have bombs nearby, don&#x27;t dig outside return True #if self.board[row][col] == 0: for r in range(max(0, row-1), min(self.height-1, row+1) + 1): for c in range(max(0, col-1), min(self.width-1, col+1) + 1): if (r, c) in self.dug: continue #checked self.dig(r, c)#recursion return True game play visible board 12345678910111213141516171819def show(self): visible_board = [[None for c in range(self.width)] for r in range(self.height)] for row in range(self.height): for col in range(self.width): if (row, col) in self.dug: tmp = number_to_emoji(self.board[row][col]) if self.board[row][col] != &#x27;💣&#x27; else &#x27;💣&#x27; visible_board[row][col] = tmp else: visible_board[row][col] = &quot;🧱&quot; print(visible_board[row][col],end=&quot; &quot;) print(&quot;&quot;)def reveal(self): for row in range(self.height): for col in range(self.width): tmp = number_to_emoji(self.board[row][col]) if self.board[row][col] != &#x27;💣&#x27; else &#x27;💣&#x27; self.board[row][col] = tmp print(self.board[row][col],end=&quot; &quot;) print(&quot;&quot;) 💡 為了方便排版，我把數字與炸彈都換成表情符號，使得間距不會差太多，function如下： 12345678910111213141516171819def number_to_emoji(num): # Define the mapping between numbers and emojis emoji_mapping = &#123; 0: &quot;0️⃣ &quot;, 1: &quot;1️⃣ &quot;, 2: &quot;2️⃣ &quot;, 3: &quot;3️⃣ &quot;, 4: &quot;4️⃣ &quot;, 5: &quot;5️⃣ &quot;, 6: &quot;6️⃣ &quot;, 7: &quot;7️⃣ &quot;, 8: &quot;8️⃣ &quot;, 9: &quot;9️⃣ &quot;, &#125; # Convert the number to a string and map each digit to its corresponding emoji emoji_str = &quot;&quot;.join(emoji_mapping[int(digit)] for digit in str(num)) return emoji_str play function流程(輸入) 創建棋盤 show出棋盤並請使用者輸入要挖的格子 輸入 If挖到炸彈，遊戲結束 If沒有，遞迴挖到周邊格子的周圍都有至少一顆地雷 重複2~5直到格子被挖完，顯示遊戲結果 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455def play(size, num_bombs): #Step 1. create board board = Board(size, num_bombs) is_safe = True while len(board.dug) &lt; board.size - board.num_bombs: #Step 2. print boards board.show() print(&quot;&quot;) #Step 3. Input tmp = input(&quot;Where would you like to dig?(col:x) (row:y):&quot;)#from 1 if tmp == &quot;reveal&quot;: board.reveal() break else: col, row = map(int, tmp.split()) col, row = col -1, row -1#from 0 #check if invalid input if row &lt; 0 or row &gt;= board.height or col &lt; 0 or col &gt;= board.width: print(&quot;Invalid location. Please try again.&quot;) continue #Step 4. &amp; 5. check result of dug is_safe = board.dig(row, col) if not is_safe: break #game over time.sleep(0.5) time.sleep(1)#wait for game over screen show up #Step 6. win or lose if is_safe: print(&quot;CONGRATULATIONS! YOU WIN!!!&quot;) time.sleep(1) tmp = input(&quot;again?(Y/N):&quot;) if tmp == &quot;Y&quot;: os.system(&#x27;cls&#x27;) size, num_bombs= title_screen() play(size, num_bombs) else: print(&quot;byebye ^ ^&quot;) else: print(&quot;SORRY, GAME OVER :(&quot;) #reveal complete board board.reveal() time.sleep(2) tmp = input(&quot;again?(Y/N):&quot;) if tmp == &quot;Y&quot;: os.system(&#x27;cls&#x27;) size, num_bombs= title_screen() play(size, num_bombs) else: print(&quot;byebye ^ ^&quot;) title screen(difficulty settings) 123456789101112131415161718192021222324252627282930313233def title_screen(): while(True): difficulty = int(input(&quot;Please Choose the Difficulty(enter number)\\n1 Beginner\\n2 Intermediate\\n3 Expert\\n4 Custom\\nmode:&quot;)) match(difficulty): case 1: size = (8, 8) num_bombs = 10 case 2: size = (16, 16) num_bombs = 40 case 3: size = (16, 30) num_bombs = 99 case 4: while(True): w,h = map(int, input(&quot;Please Enter Width and Height for the board(up to 80, 80):&quot;).split()) if w &gt; 35 or w &lt; 0 or h &gt; 35 or h &lt; 0: print(&quot;Width and Height of map should be between 0 and 35. Please Try Again.&quot;) continue else: num_bombs = int(input(&quot;Please Enter The Number of Bombs:&quot;)) if num_bombs &gt; 300 or num_bombs &lt; 0: print(&quot;Number of bombs should be between 0 and 300. Please Try Again.&quot;) continue break size = (w, h) case _: print(&quot;Invalid Input&quot;) time.sleep(1.5) os.system(&#x27;cls&#x27;) continue break return size, num_bombs 最後兩個function就能玩啦！ 12size, num_bombs= title_screen()play(size, num_bombs) 結語文章頗長，感謝您的觀看！完整程式碼我會放在這裡，另外，文章中的遊戲只能在終端運行，並且輸入必須用座標來寫也是略為麻煩，早就被介面化的應用程式麻痺的我們怎麼可能忍的了呢！所以下一篇文章，就要用Pygame做出互動介面，還請您敬請期待！"},{"title":"LeetCode 1. two-sum","path":"2023/12/16/leetcode-two-sum/","text":"題目連結：https://leetcode.com/problems/two-sum/description/ 算是Leetcode最經典的題目之一了，所有初學者第一題應該都是從這裡開始的(包括我)，廢話不多說，開始！ Brute Force 暴力迴圈解12345678class Solution: def twoSum(self, nums: List[int], target: int) -&gt; List[int]: n= len(nums) for i in range(n-1): for k in range(i+1, n): if (nums[i] + nums[k]) == target: return [i, k] return [] # no solution 我一開始也是很輕鬆地寫出了一個迴圈解，不過這個寫法的缺點也很明顯，因為有兩個迴圈，我們的 時間複雜度會是O(n^2) ，不過只會使用到用於輸出的常數，所以 空間複雜度會是O(1) 。 Hash Table 雜湊表使用雜湊表，就只需要把元素放到雜湊表一次，再透過其中一個答案反推，所以時間複雜度會是 O(n) ，但因為要創建雜湊表，所以空間複雜度也會是 O(n) 。 Two-pass Hash Table 遍歷兩次123456789101112131415class Solution: def twoSum(self, nums: List[int], target: int) -&gt; List[int]: n= len(nums) num_map = &#123;&#125; #hash table for i in range(n): num_map[nums[i]] = i # 因為要找的是index，所以index放在value的位置 for i in range(n): complement = target - nums[i] if complement in num_map and num_map[complement] != i: return [i, num_map[complement]] return [] # no solution 可以簡單理解為a + b &#x3D; target，所以targer - a &#x3D; b當目標與現在數字的差值如果在表中(也就是target - a &#x3D; b在表中)、並且b的位置不等於a的位置(避免同一個元素被使用)。 One-pass Hash Table 遍歷一次123456789101112class Solution: def twoSum(self, nums: List[int], target: int) -&gt; List[int]: n= len(nums) num_map = &#123;&#125; for i in range(n): complement = target - nums[i] if complement in num_map: return [num_map[complement], i] # return的順序會反過來 num_map[nums[i]] = i # 這時候才把數字加到雜湊表 return [] # no solution 這個邏輯是先判斷再把數字加入雜湊表，所以第一個答案先被算出來也不會使判斷式成立，而是從後面的數字反推前面的，所以算出答案時的complement會是前面的答案，所以return的順序會反過來。"},{"title":"深度學習到底如何運作？","path":"2023/12/14/DeepLearning/","text":"認識神經網路神經元(Neuron) 構造 細胞本體：控管整個神經元。 樹突：輸入。 神經纖維：傳遞訊息，如果越常使用，此神經會的反應會越明顯。 軸突：輸出。 運作方式 感知器(Perceptron) 構造 x：輸入數值。 w：權重，代表輸入數值的重要程度，正如神經纖維的反應會變動一樣，這表示權重的數值會不斷的改變，這也是為甚麼AI模型需要經過不斷的訓練。 φ：激勵函數，規範數值的範圍 b：偏移，加權總和要超過甚麼數字才有意義，用以規範數值有意義的範圍。 h：輸出數值，也就是所獲得的結果。 以圖像來思考，綠色為正的權重，紅色為負的權重，顏色愈亮代表與0的差距越大。神經元透過權重來計算下一層神經元所注重的圖像。而我們可以將我們所要的圖像外的權重值都改為0。如果想要確認圖形的邊，可以在外圍的偏移改為負的權重，就可以得到最大的加權總和。 什麼是邏輯函數(Sigmoid Function)，這個函數有什麼特別之處?我們想要計算權重的總和，加權總和可能為任意實數，但我們需要將加權總和壓縮在0到1之間(不包含0且不包含1)以便利用，sigmoid function(邏輯函數)就是使加權總和壓縮在0到1之間的工具，如圖。 眼尖的人應該有發現，方程式內的稱為激勵函數，而下文介紹的是邏輯函數，事實上，邏輯函數只是激勵函數的一種，激勵函數還有ReLU、tanh、Maxout函數等等，範圍也不僅限於0或1之間，不過那是另一個故事了 那到底為甚麼要套入激勵函數呢，因為如果不這麼做，會導致方程式為線性函數，那為甚麼會是線性函數呢？以國中數學舉例來說，f(x) &#x3D; 2x +1，g(x) &#x3D; 3f(x) + 2，則f(x)帶入後會得到g(x) &#x3D; 3(2x+1) +1，g(x)&#x3D; 6x+4，還是一個線性函數。 這代表你只要給了每個輸出都獨立對一個輸出，一開始就是因為沒有加上這個邏輯函數導致原函數是線性的，這個線性函數解決不了exclusive or的問題。 如圖，一條線是無法分開綠色的點與紅色的點的。這也導致連結主義學派沒落好一段時間…… 多層感知機運作方式 多層感知機是一種前向傳遞類神經網路，還有一點要注意的是隱藏層並不是越多越好。 也有反向傳遞的方式，在損失函數調整偏值後，會重新調整先前所有權重的值，用來降低誤差 其餘更詳細歡迎看：機器學習-神經網路-多層感知機 資料來源：But what is a neural network? | Chapter 1, Deep learning Demystifying the XOR problem"},{"title":"認識AI與機器學習","path":"2023/12/10/learning_ai/","text":"先來說說AI是甚麼，人工智慧（AI）是指讓機器展現出與人類智慧相似的能力和行為的領域，重點在於思考與理解的能力。 而機器學習是AI的一個子集，關係圖如下，它是通過讓機器從數據中學習和改進，自動提取模式、規則和知識，從而實現各種任務，例如圖像識別、語音辨識、自然語言處理等。 AI工程師有哪些？資料分析師&#x2F;數據分析師(Data Analyst) 資料分析師是負責收集、整理、分析和解釋數據的專業人員。主要使用統計和分析工具(清洗與分析)，用圖表以展現數據中的模式、趨勢和關聯性(視覺化處理)，進而提供對市場或公司的資料觀察結果。 需要了解的知識有： Matplotlib(常用) 統計學 Seaborn 友情推薦：粉專-資料科學家的工作日常 資料工程師(Data Engineer) 資料工程師是負責設計、構建、維護和處理大規模數據的專業人員，需要把凌亂的資料轉成乾淨的資料，他們主要關注的是數據的流動、轉換和儲存(資料庫)。 需要了解的知識有： SQL database(SEL, Structured Query Language結構化查詢語言) Python(資料處理) Machine Learning 資料科學家(Data Scientist) 與資料分析師類似，一樣需要對資料進行清洗、分析、視覺化，不過更注重在於構建機器學習模型並訓練用於分析或是預測數據。 需要了解的知識有： PyTorch or TensorFlow 統計學 製作model(模型) 延伸閱讀資料工程師們到底在做什麼資料分析師、資料科學家、資料工程師傻傻分不清楚？一文徹底講清區別 把問題化為函數函數函數，其實與數學上所說的函數一樣，即為function之意。 X 是定義域，Y 是值域，每一個 X 裡的元素，都要對應到 Y 裡的一個元素，而且只能對到一個。 用人話說，就是函數(function)是一個解答本，X是所有可能的題目（問題）， Y 則是所有可能的答案。 函數的定義就是讓所有的題目都要有解答，並且是唯一的答案。 AI解決問題的過程1.先問一個問題 一個問題有很多不同的問法，有時我們不能直接問這個問題，而是要換一種方式來問。 「問一個好問題」是人工智慧中最重要的部分之一了！ 2.把問題化成函數的形式 所有的問題都需要有解答，我們需要函式來讓我們得到答案。 3.收集歷史資料 接著，AI需要蒐集「考古題」，經過大量收集歷史數據後，才能讓解答本越來越完善。 但AI就像班上那些背科很強的同學，他也會把考古題背起來，但如果遇到沒有看過的題目，他就會回答得非常離譜，這種狀況叫做過適或過度擬合(overfitting)。 4.打造一個函數學習機 這是使AI有思考能力的轉捩點，透過機器學習(machine learning)或神經網路(neural network)等方法來建構函數學習機，經過大量的資料學習過後，直到找到一個最好的參數來滿足我們所想要的函式，函數學習機就完成了。 舉例來說，我們想要找到最適直線y &#x3D; wx + b，當我們決定好(w, b) &#x3D; (2, 3)時，函數學習機就完成了 5.訓練 最後要訓練函數學習機，每次的訓練都會調整我所設定的參數，使函式更接近理想函式。 以最適直線來舉例，實際的數據也不一定會在最適直線上，那我們需要知道差的值到底是多少。就會透過損失函數來計算誤差，所以好的函數會希望損失函數越來越小。 損失函數有很多種，例如我們高中學過的最小平方法 補充一下，使用平方是為了避免負值，那就可能有人問了，那為甚麼不用絕對值呢？這是因為在更高維度的時候可能就不只有一個維度的正負了，再者，平方後也可以擴大離散差距，也能讓更方便應用微積分。 資料的處理步驟與流程 img[alt=data-processing-flow] { width: 30%;} 預處理的目的？ 去除雜質(不必要的東西) 將資料轉換成方便電腦閱讀的形式 甚麼是候選模型？訓練出來會有很多個模型，假設有100個模型，在這裡我們可能會選出最好的三個模型，作為我們的候選模型。最後再選出一位最佳候選模型，作為Golden Model(金鑰模型)。 機器學習(ML)演算法分類與分群分類 Classification就是將物品分類至已經存在的類別 以函數表示會像這樣： YLabel1=f1(x1,x2,...,xn)Y_{Label1} = f_1(x_1, x_2, ..., x_n)YLabel1​=f1​(x1​,x2​,...,xn​) YLabel2=f2(x1,x2,...,xn)Y_{Label2} = f_2(x_1, x_2, ..., x_n)YLabel2​=f2​(x1​,x2​,...,xn​) 分類的結果稱為標籤(Label)，也就是Y &#x3D; function 判斷結果的資料叫做特徵(Feature)，也就是x1,x2…。 簡單來說，就是將特徵(Feature)分類到已知的種類資訊，得到標籤(Label) 分群 Clustering將物品分成至尚未存在的類別 其他跟分類一樣， 分群的結果稱為標籤(Label) 判斷結果的資料叫做特徵(Feature) 簡單來說，就是將特徵(Feature)分群到未知的種類資訊，得到標籤(Label) 機器學習類別 監督式學習 非監督式學習 半監督式學習 強化式學習 資料來源 有標記(labeled) 無標記(labeled) 混合有標記與無標記 與環境互動 方法 將已知迴歸分析 從未知尋找既定模式(例如K平均演算法) 提升模型正確率 透過正面回饋與負面回饋尋找最大效益 優點 準確率高 不需要標籤 標註成本低、數量少 效率較高 缺點 需要大量人力作業 可能造成不具重要性的特徵被過度放大 可能造成不具重要性的特徵被過度放大 容易過度擬合"},{"title":"APCS 2016/03 矩陣轉換","path":"2023/11/11/apcs_2016_03/","text":"第 2 題 矩陣轉換題目連結 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960#輸入R, C, M = map(int, input().split())matrix = []for i in range(R): x = list(map(int, input().split())) matrix.append(x)moves = list(map(int, input().split()))&quot;&quot;&quot;原本的輸出經過1,0,0才得到後來的圖形則後來的圖形需要經過0,0,1才能得到原來的圖形&quot;&quot;&quot;moves = list(reversed(moves))#翻轉與旋轉def flip(matrix): &quot;&quot;&quot; 讀取行(橫的)，這裡直接用reversed函式就好，記得外面要加list() [1, 1] -&gt; [1, 2] [3, 1] -&gt; [3, 1] [1, 2] -&gt; [1, 1] &quot;&quot;&quot; return list(reversed(matrix))def rotate_left(matrix): &quot;&quot;&quot; 讀取列(直的)， index:(0,0)(1,0)(2,0)(0,1)(1,1)(2,1) [1, 2] -&gt; [1, 3, 1] -&gt; [2, 1, 1] [3, 1] -&gt; [2, 1, 1] -&gt; [1, 3, 1] [1, 1] -&gt; &quot;&quot;&quot; temp = [] row = len(matrix) col = len(matrix[0]) for i in range(col): temp_row = [] for k in range(row): temp_row.append(matrix[k][i]) temp.append(temp_row) return list(reversed(temp))#執行movesfor i in range(M): if moves[i] == 1: matrix = flip(matrix) elif moves[i] == 0: matrix = rotate_left(matrix)#輸出ROW = len(matrix)COL = len(matrix[0])print(ROW, COL)for k in range(ROW): print(*matrix[k]) 第 3 題 線段覆蓋長度題目連結 1234567891011121314151617181920212223242526272829303132#輸入N = int(input())lines = []for i in range(N): x = list(map(int, input().split())) lines.append(x)#由小排到大，等等好擴張線段大小lines.sort()start = lines[0][0] #起始線段的左邊end = lines[0][1] #起始線段的右邊sum = 0 #判斷for i in lines: left = i[0] right = i[1] if end &lt; left:#沒有覆蓋到線段 #計算獨立線段長度 sum += end - start #線段轉換成一個 start = left end = right else:#覆蓋到線段 #保持原有線段擴張 end = max(end, right)#最後剩下的那個線段記得加sum += end - start#輸出print(sum)"},{"title":"從純文字到精美文件|10分鐘帶你看完Markdown全語法","path":"2023/10/21/MarkdownSyntax/","text":"前言甚麼是MarkDown?Markdown是一種輕量級標記語言，目標很簡單，就是實現「易讀易寫」。並在不需要特殊複雜排版的情況下就能輕鬆地將內容轉換為HTML或其他格式。 為甚麼你該學Markdown?Markdown文本在原始形式下很容易閱讀，就像一般的記事本一樣，頂多就是多了一些明顯的符號(例如星號**用於標記強調文字)。 最重要的是許多平台都已經可以使用Markdown語法來撰寫留言、文件了，例如Github、Stack Overflow、甚至是Discord、Youtube、Line等等通訊、娛樂軟體都或多或少的支援Markdown。 簡單的說，Markdown已經是我們在大數位時代中的一個不可或缺的知識。 基礎寫法標題最多從h1~h6。 Code123456789# h1## h2### h3#### h4h1===h2--- Showcase分隔線Code12345* * *********- - ---------------------------------------- Showcase 換行Code123直接按enter是不管用的！ 換行是兩個空格 + enter Showcase直接按enter是不管用的！換行是 兩個空格 + enter 列表無序列表Code12345- 項目1 + 子項目1 - 子項目2+ 項目2* 項目3 Showcase 項目1 子項目1 子項目2 項目2 項目3 有序列表Code123453. 列表的數字只會照著第一個數下去 1. 第一個子項目 3. 第二個子項目2. 第二個項目1. 第三個項目 Showcase 列表的數字只會照著第一個數下去 第一個子項目 第二個子項目 第二個項目 第三個項目 勾選Code12- [ ] 去買蛋餅- [x] 刷一題code Showcase 去買蛋餅 刷一題code 引用&#x2F;註解Code12&gt; 你好，我是註解&gt;&gt; 你好，我是註解中的註解 Showcase 你好，我是註解 你好，我是註解中的註解 斜體(Italic type)與強調(Bold)Code123456*一個星號* _一個底線_ **兩個星號** __兩個底線__ ***三個星號*** ___三個底線___ Showcase 一個星號一個底線兩個星號兩個底線三個星號三個底線 超連結[顯示文字](連結) Code123[點我會到google喔(ﾉ&gt;ω&lt;)ﾉ](http://google.com) [點我會到google喔(ﾉ&gt;ω&lt;)ﾉ](http://google.com &quot;欸呦這可以到Google欸&quot;) 滑鼠放在上面會看到註解 Showcase 點我會到google喔(ﾉ&gt;ω&lt;)ﾉ點我會到google喔(ﾉ&gt;ω&lt;)ﾉ滑鼠放在上面會看到註解 那如果常常要用同一個超連結怎麼辦？我們可以使用超連結標籤。在任意地方定義 [id]:連結 “備註” 這段代碼。(就像變數的概念，有點像 id &#x3D; http://google.com ，並重複使用id變數的感覺。) Code12345[123]: http://google.com &quot;這是GOOGLE網址&quot; [123][Y]: http://youtube.com [Y] Showcase 123 Y 程式碼文字中程式碼Code1用個單個`code`引號就好 Showcase 用個單個code引號就好 如果不希望引號內變成程式碼呢？或是程式碼內有單引號呢？可以用兩個單引號包起來，或是在單引號前加上\\，當然，用html寫也可以。 Code12345``一堆`單`引`號`。`` &lt;p&gt;一堆`單`引`號`。&lt;p&gt;一堆\\`單\\`引\\`號\\`。 Showcase一堆`單`引`號`。 一堆`單`引`號`。 一堆`單`引`號`。 圖片![屬性註解](圖片連結) 或是 [![屬性註解](圖片連結)](超連結) Code12![烏龜](https://cdn3.emoji.gg/emojis/8947-turtle4k.png)[![能點的烏龜](https://cdn3.emoji.gg/emojis/8947-turtle4k.png)](https://emoji.gg/emoji/8947-turtle4k) Showcase 有沒有覺得烏龜太大隻？如果想調整圖片大小，就只能用html或css來處理： Code12345&lt;img src=&quot;https://cdn3.emoji.gg/emojis/8947-turtle4k.png&quot; with=&quot;200px&quot; alt=&quot;第三隻烏龜&quot;&gt; ![第四隻烏龜](https://cdn3.emoji.gg/emojis/8947-turtle4k.png) &lt;style&gt;img[alt=第四隻烏龜] &#123; width: 40%; &#125;&lt;/style&gt; Showcase img[alt=第四隻烏龜] { width: 40%; } img[alt=第三隻烏龜] { width: 200px; } 表格Code123456789| 你好嗎 | 我很好阿 | 真的還假的 | | ----- | ----- | ----- | | ABC | DEF | GHI | | JKL | MNO | PQR || 左對齊 | 右對齊 | 居中對齊 | | :-----| ----: | :----: | | ABC | DEF | GHI | | JKL | MNO | PQR | Showcase 你好嗎 我很好阿 真的還假的 ABC DEF GHI JKL MNO PQR 左對齊 右對齊 居中對齊 ABC DEF GHI JKL MNO PQR 進階寫法🚧🚧🚧🚧🚧仍在努力製作中&gt;&lt;"},{"title":"我架設了一個Blog。","path":"2023/10/14/Origin_of_Blog/","text":"創造這個網站的原因？你好，歡迎來到這個網站的起源，這是這個網站的第一篇文章原本想創這個網站是為了放自己刷leetcode心得，順便練習html,css,js，後來想說就把一些學到的東西都丟上來，自己當筆記看以外還可以讓更多有興趣的人了解這些資訊 從bootstrap到hexo於是乎，我就馬上找了個bootstrap範本開始研究，稍微改了一點東西就丟到github pages了，然後我就發現這樣要寫文章真的超麻煩啊!!!!!! 要手動去github新增新的html不說，當文章多起來的時候，重要標籤、搜尋功能都不存在，這樣到底怎麼找文章啦😭於是我就開始另闢蹊徑，最終決定使用hexo來架起我的Blog 架好了，在此留下我的喜悅！1print(&quot;^_^ Say hello to my little friend!&quot;) 最後想說的話距離高三還有一年，我想這段時間還是能夠在這裡挺活躍的，不過當然同時也要準備好課業喔各位，不要像我一樣整天亂亂搞！感謝聽我廢話到這邊~希望以後也能常常相見！ 更瞭解我: About Me"}]